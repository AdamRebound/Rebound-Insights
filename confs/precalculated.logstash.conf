input {
    jdbc {
        id => "business_jdbc"
        jdbc_connection_string => "jdbc:sqlserver://desktop-pnhfnpj:1433;databaseName=Dev;integratedSecurity=false;"
        jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"
        jdbc_user => "Manchester"
        jdbc_password => "R3B0undM@n"
        jdbc_page_size => 100000
        jdbc_paging_enabled => true
        tracking_column => "date"
        tracking_column_type => "timestamp"
        use_column_value => true
        statement => "SELECT * FROM business_table WHERE Date >:sql_last_value ORDER BY client_id, date"
        type => "business"
        schedule => "*/60 */24 * * *"  # Execute now and after - every day at 00:00
        # last_run_metadata_path => "/test_delayed_parcels_data_last_run_file"
    } 
    jdbc {
        id => "operations_jdbc"
        jdbc_connection_string => "jdbc:sqlserver://desktop-pnhfnpj:1433;databaseName=Dev;integratedSecurity=false;"
        jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"
        jdbc_user => "Manchester"
        jdbc_password => "R3B0undM@n"
        jdbc_page_size => 100000
        jdbc_paging_enabled => true
        tracking_column => "date"
        tracking_column_type => "timestamp"
        use_column_value => true
        statement => "SELECT * FROM operations_table WHERE Date >:sql_last_value ORDER BY client_id, date"
        type => "operations"
        schedule => "*/60 */24 * * *"  # Execute now and after - every day at 00:00
        # last_run_metadata_path => "/test_delayed_parcels_data_last_run_file"
    }  
    jdbc {
        id => "customer_jdbc"
        jdbc_connection_string => "jdbc:sqlserver://desktop-pnhfnpj:1433;databaseName=Dev;integratedSecurity=false;"
        jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"
        jdbc_user => "Manchester"
        jdbc_password => "R3B0undM@n"
        jdbc_page_size => 100000
        jdbc_paging_enabled => true
        tracking_column => "date"
        tracking_column_type => "timestamp"
        use_column_value => true
        statement => "SELECT * FROM customer_table WHERE Date >:sql_last_value ORDER BY client_id, date"
        type => "customer"
        schedule => "*/60 */24 * * *"  # Execute now and after - every day at 00:00
        # last_run_metadata_path => "/test_delayed_parcels_data_last_run_file"
    }  
}
filter {
    aggregate {
        task_id => "%{client_id}%{date}"
        code => "
            map['*'] = event.get('*')
            event.cancel()
        "
    }
    inactivity_timeout => 60  #seconds since last event
    push_map_as_event_on_timeout => true
    timeout_task_id_field => "task_id"
}
output {
    elasticsearch {
        index => "%{client_id}_metrics"
        document_id => "%{id}"
        hosts => "localhost:8080"
    }
    stdout { codec => rubydebug }
}